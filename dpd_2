import pandas as pd
import numpy as np
from datetime import datetime

def calculate_monthly_dpd(df):
    """
    Calculate DPD for each dealid for every month from 2020-01-01 to 2025-11-01
    
    Logic: 
    - DPD grows from valuedate to tilldate
    - After tilldate (loan resolved), DPD resets to 0
    - One row per dealid per month
    - If multiple past due periods exist, take the maximum DPD
    
    Parameters:
    -----------
    df: DataFrame with columns ['dealid', 'valuedate', 'tilldate']
    
    Returns:
    --------
    DataFrame with columns ['dealid', 'reporting_date', 'dpd', 'status']
    """
    
    # Convert date columns to datetime
    df = df.copy()
    df['valuedate'] = pd.to_datetime(df['valuedate'])
    df['tilldate'] = pd.to_datetime(df['tilldate'])
    
    # Generate monthly reporting dates (first day of each month)
    date_range = pd.date_range(start='2020-01-01', end='2025-11-01', freq='MS')
    
    # Get unique dealids
    dealids = df['dealid'].unique()
    
    result_data = []
    
    for dealid in dealids:
        # Get all past due periods for this dealid
        deal_records = df[df['dealid'] == dealid].sort_values('valuedate')
        
        for reporting_date in date_range:
            max_dpd = 0
            status = 'current'
            
            for _, record in deal_records.iterrows():
                valuedate = record['valuedate']
                tilldate = record['tilldate']
                
                # Calculate DPD based on reporting date position
                if reporting_date < valuedate:
                    # Past due hasn't started yet
                    dpd = 0
                elif reporting_date <= tilldate:
                    # Currently in past due period
                    dpd = (reporting_date - valuedate).days
                    status = 'past_due'
                else:
                    # Past due resolved (loan paid/closed)
                    dpd = 0
                    status = 'current'
                
                # Take maximum DPD if multiple periods overlap
                if dpd > max_dpd:
                    max_dpd = dpd
            
            result_data.append({
                'dealid': dealid,
                'reporting_date': reporting_date,
                'dpd': max_dpd,
                'status': status if max_dpd > 0 else 'current'
            })
    
    # Create result dataframe
    result_df = pd.DataFrame(result_data)
    
    return result_df


def add_dpd_buckets(result_df):
    """
    Add standard DPD buckets following Basel III guidelines
    
    Buckets:
    - Current: 0 days
    - 1-30 DPD: Early delinquency
    - 31-60 DPD: Moderate delinquency
    - 61-90 DPD: Serious delinquency
    - 91-180 DPD: Severe delinquency
    - 180+ DPD: Default (typically NPL - Non-Performing Loan)
    """
    result_df = result_df.copy()
    
    conditions = [
        result_df['dpd'] == 0,
        result_df['dpd'].between(1, 30),
        result_df['dpd'].between(31, 60),
        result_df['dpd'].between(61, 90),
        result_df['dpd'].between(91, 180),
        result_df['dpd'] > 180
    ]
    
    choices = ['Current', '1-30 DPD', '31-60 DPD', '61-90 DPD', 
               '91-180 DPD', '180+ DPD (NPL)']
    
    result_df['dpd_bucket'] = np.select(conditions, choices, default='Unknown')
    
    return result_df


def get_summary_statistics(result_df):
    """
    Generate summary statistics for DPD analysis
    """
    summary = {
        'total_deals': result_df['dealid'].nunique(),
        'total_observations': len(result_df),
        'avg_dpd_overall': result_df['dpd'].mean(),
        'avg_dpd_when_past_due': result_df[result_df['dpd'] > 0]['dpd'].mean(),
        'max_dpd': result_df['dpd'].max(),
        'deals_ever_past_due': result_df[result_df['dpd'] > 0]['dealid'].nunique(),
        'pct_months_with_past_due': (result_df['dpd'] > 0).sum() / len(result_df) * 100
    }
    
    return pd.Series(summary)


def get_monthly_delinquency_rate(result_df):
    """
    Calculate monthly delinquency rates (% of deals past due each month)
    """
    monthly = result_df.groupby('reporting_date').agg({
        'dealid': 'count',
        'dpd': lambda x: (x > 0).sum()
    }).rename(columns={'dealid': 'total_deals', 'dpd': 'past_due_deals'})
    
    monthly['delinquency_rate_%'] = (monthly['past_due_deals'] / monthly['total_deals'] * 100).round(2)
    
    return monthly


# Example usage:
"""
# Load your data
df = pd.DataFrame({
    'dealid': ['CLIENT001', 'CLIENT002', 'CLIENT001', 'CLIENT003'],
    'valuedate': ['2020-03-15', '2021-06-20', '2024-01-10', '2020-05-01'],
    'tilldate': ['2020-05-20', '2021-08-15', '2024-03-05', '2020-12-31']
})

# Calculate DPD
result = calculate_monthly_dpd(df)

# Add risk buckets
result = add_dpd_buckets(result)

# View sample results
print("Sample DPD Results:")
print(result.head(20))

# Summary statistics
print("\n=== PORTFOLIO SUMMARY ===")
print(get_summary_statistics(result))

# Monthly delinquency trends
print("\n=== MONTHLY DELINQUENCY RATES ===")
monthly_delq = get_monthly_delinquency_rate(result)
print(monthly_delq.head(10))

# View specific client's DPD history
print("\n=== CLIENT001 DPD HISTORY ===")
print(result[result['dealid'] == 'CLIENT001'])

# Filter to see only past due periods
print("\n=== PAST DUE RECORDS ONLY ===")
past_due = result[result['dpd'] > 0]
print(past_due)

# Export to Excel with multiple sheets
with pd.ExcelWriter('dpd_analysis.xlsx', engine='openpyxl') as writer:
    result.to_excel(writer, sheet_name='Full_DPD_Data', index=False)
    get_monthly_delinquency_rate(result).to_excel(writer, sheet_name='Monthly_Trends')
    result[result['dpd'] > 0].to_excel(writer, sheet_name='Past_Due_Only', index=False)

print("\nâœ“ Excel file saved: dpd_analysis.xlsx")
"""
